<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Busca Minas</title>
  <style>
    :root{
      --azul:#03658C; --amarillo:#F2B705; --rojo:#F20505; --verde:#2ecc71; --gris:#ecf0f1; --gris2:#bdc3c7;
    }
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Noto Sans',sans-serif; margin:0; background:#f7fbff; color:#063;}
    .container{max-width:900px; margin:0 auto; padding:16px;}
    .panel{
      background:#fff; border:2px solid var(--azul); border-radius:12px; padding:12px; box-shadow:0 10px 22px rgba(6,9,102,0.08);
    }
    h1{font-size:1.25rem; margin:0 0 10px; color:var(--azul)}
    .controls{display:flex; flex-wrap:wrap; align-items:center; gap:10px; margin-bottom:10px}
    .controls .stat{background:#fff; border:1px solid var(--azul); color:var(--azul); padding:6px 10px; border-radius:8px; font-weight:700}
    .controls label{font-weight:600; color:#024}
    .controls select, .controls input[type="number"]{padding:6px 8px; border:1px solid #aac; border-radius:8px}
    .btn{background:var(--azul); border:0; color:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700}
    .btn:hover{background:var(--amarillo); color:var(--azul)}

    .board-wrap{overflow:auto; border-radius:10px; border:2px solid var(--azul);}
    .board{display:grid; background:#dff1ff;}

    .cell{width:34px; height:34px; display:flex; align-items:center; justify-content:center; user-select:none; cursor:pointer;
      border:1px solid #c6d9e6; font-weight:700; font-size:15px;}
    .cell.hidden{background:linear-gradient(#e8f6ff, #caeaff);}
    .cell.revealed{background:#fff; border-color:#e6eef5; cursor:default}
    .cell.flag{background:#fff5d6}
    .cell.mine.revealed{background:#ffe6e6}

    .n1{color:#1976d2} .n2{color:#2e7d32} .n3{color:#d32f2f} .n4{color:#512da8}
    .n5{color:#c62828} .n6{color:#00897b} .n7{color:#5d4037} .n8{color:#455a64}

    .footer{margin-top:10px; font-size:0.9rem; color:#024}
  </style>
</head>
<body>
  <div class="container">
    <div class="panel">
      <h1>Busca Minas</h1>
      <div class="controls">
        <div class="stat">‚è±Ô∏è <span id="time">0</span>s</div>
        <div class="stat">üí£ <span id="mines-left">0</span></div>
        <label for="size">Tama√±o:</label>
        <select id="size" aria-label="Tama√±o del tablero">
          <option value="9x9x10">9x9 (10 minas)</option>
          <option value="12x12x20">12x12 (20 minas)</option>
          <option value="16x16x40">16x16 (40 minas)</option>
        </select>
        <button id="new-game" class="btn">Nuevo juego</button>
        <span style="margin-left:auto"></span>
        <span title="Instrucciones">Click: revelar | Bot√≥n derecho: bandera</span>
      </div>
      <div class="board-wrap">
        <div id="board" class="board" role="grid" aria-label="Tablero Busca Minas"></div>
      </div>
      <div class="footer" id="msg" aria-live="polite"></div>
    </div>
  </div>

  <script>
    (function(){
      const boardEl = document.getElementById('board');
      const minesLeftEl = document.getElementById('mines-left');
      const timeEl = document.getElementById('time');
      const msgEl = document.getElementById('msg');
      const sizeSel = document.getElementById('size');
      const newBtn = document.getElementById('new-game');

      let rows=9, cols=9, mines=10;
      let grid = []; // {mine:boolean, r:int, c:int, adj:int, revealed:boolean, flagged:boolean}
      let started = false; let over = false; let revealedCount = 0; let timerId=null; let seconds=0; let flagsLeft = mines;

      function parseSize(){
        const [r,c,m] = sizeSel.value.split('x').map(Number);
        rows = r; cols=c; mines=m;
      }

      function within(r,c){ return r>=0 && r<rows && c>=0 && c<cols; }
      function neighbors(r,c){
        const out=[]; for(let dr=-1; dr<=1; dr++){ for(let dc=-1; dc<=1; dc++){
          if(dr===0 && dc===0) continue; const nr=r+dr, nc=c+dc; if(within(nr,nc)) out.push([nr,nc]);
        }} return out;
      }

      function placeMines(safeR, safeC){
        // Avoid placing mine at first clicked cell and its neighbors
        const forbidden = new Set([`${safeR},${safeC}`,...neighbors(safeR,safeC).map(([r,c])=>`${r},${c}`)]);
        let placed=0; while(placed<mines){
          const r = Math.floor(Math.random()*rows);
          const c = Math.floor(Math.random()*cols);
          const key = `${r},${c}`;
          if(forbidden.has(key)) continue;
          const cell = grid[r][c];
          if(!cell.mine){ cell.mine=true; placed++; }
        }
        // Compute adjacents
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            if(grid[r][c].mine){ grid[r][c].adj = -1; continue; }
            let count=0; neighbors(r,c).forEach(([nr,nc])=>{ if(grid[nr][nc].mine) count++; });
            grid[r][c].adj = count;
          }
        }
      }

      function startTimer(){
        if(timerId) clearInterval(timerId); seconds=0; timeEl.textContent='0';
        timerId = setInterval(()=>{ seconds++; timeEl.textContent = String(seconds); }, 1000);
      }
      function stopTimer(){ if(timerId) { clearInterval(timerId); timerId=null; } }

      function reset(){
        over=false; started=false; revealedCount=0; parseSize(); flagsLeft = mines; minesLeftEl.textContent=String(flagsLeft);
        msgEl.textContent = '';
        boardEl.innerHTML='';
        boardEl.style.gridTemplateColumns = `repeat(${cols}, 34px)`;
        boardEl.style.gridTemplateRows = `repeat(${rows}, 34px)`;
        grid = Array.from({length:rows}, (_,r)=> Array.from({length:cols},(_,c)=>({
          r,c, mine:false, adj:0, revealed:false, flagged:false, el:null
        })));
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const div = document.createElement('div');
            div.className='cell hidden';
            div.setAttribute('role','gridcell');
            div.setAttribute('aria-label',`Celda ${r+1},${c+1}`);
            div.dataset.r=r; div.dataset.c=c;
            grid[r][c].el = div;
            boardEl.appendChild(div);
          }
        }
        stopTimer(); timeEl.textContent='0';
      }

      function reveal(r,c){
        const cell = grid[r][c];
        if(cell.revealed || cell.flagged || over) return;
        cell.revealed = true; cell.el.classList.remove('hidden'); cell.el.classList.add('revealed');
        revealedCount++;
        if(cell.mine){
          cell.el.textContent = 'üí£'; cell.el.classList.add('mine');
          gameOver(false);
          return;
        }
        if(cell.adj>0){ cell.el.textContent = String(cell.adj); cell.el.classList.add('n'+cell.adj); }
        else {
          // Flood fill
          neighbors(r,c).forEach(([nr,nc])=>{ if(!grid[nr][nc].revealed) reveal(nr,nc); });
        }
        checkWin();
      }

      function toggleFlag(r,c){
        const cell = grid[r][c];
        if(cell.revealed || over) return;
        cell.flagged = !cell.flagged;
        if(cell.flagged){ cell.el.textContent='üè≥Ô∏è'; cell.el.classList.add('flag'); flagsLeft--; }
        else { cell.el.textContent=''; cell.el.classList.remove('flag'); flagsLeft++; }
        minesLeftEl.textContent = String(flagsLeft);
      }

      function firstClick(r,c){
        placeMines(r,c); started=true; startTimer();
        reveal(r,c);
      }

      function gameOver(win){
        over = true; stopTimer();
        // Reveal all mines
        for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
          const cell = grid[r][c];
          if(cell.mine){ cell.el.classList.add('revealed','mine'); if(!cell.flagged) cell.el.textContent = 'üí£'; }
        }
        msgEl.textContent = win ? `¬°Ganaste en ${seconds}s!` : '¬°BOOM! Perdiste. Intenta de nuevo.';
      }

      function checkWin(){
        // Win if all non-mine cells revealed
        const totalCells = rows*cols;
        if(revealedCount === totalCells - mines){ gameOver(true); }
      }

      // Events
      boardEl.addEventListener('click', (e)=>{
        const target = e.target.closest('.cell'); if(!target) return;
        const r = Number(target.dataset.r), c = Number(target.dataset.c);
        if(!started) return firstClick(r,c);
        reveal(r,c);
      });
      boardEl.addEventListener('contextmenu', (e)=>{
        e.preventDefault();
        const target = e.target.closest('.cell'); if(!target) return;
        const r = Number(target.dataset.r), c = Number(target.dataset.c);
        if(!started){ // permite marcar antes de iniciar
          started=true; // inicia temporizador aunque marques primero
          // Evitar colocar minas sobre primera acci√≥n, simular primer click seguro en celda opuesta
          const safeR = Math.floor(rows/2), safeC = Math.floor(cols/2);
          placeMines(safeR, safeC); startTimer();
        }
        toggleFlag(r,c);
      });
      newBtn.addEventListener('click', ()=> reset());
      sizeSel.addEventListener('change', ()=> reset());

      // Init
      reset();
    })();
  </script>
</body>
</html>
